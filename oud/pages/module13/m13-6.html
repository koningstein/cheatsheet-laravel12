<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <title>Mocking & Spies - Quality Assurance - Laravel 12</title>
    <link rel="stylesheet" href="../../../style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="../../../script.js" defer></script>
</head>
<body>
<div class="top-bar"><div class="top-bar-content"><div class="nav-group"><a href="../module12/m12-7.html">« Services & Features</a></div><div class="nav-group theme-switcher"><select id="theme-switcher"><option value="blue">Blauw</option></select></div></div></div>

<div class="container">
    <div class="header-nav-block">
        <header>
            <h1>Quality Assurance</h1>
            <p>Codekwaliteit, testen met PHPUnit, Pest & Dusk, en debugging.</p>
        </header>
        <nav>
            <ul>
                <li><a href="m13-1.html">Introductie & PHPUnit</a></li>
                <li><a href="m13-2.html">Unit vs Feature Tests</a></li>
                <li><a href="m13-3.html">Introductie Pest</a></li>
                <li><a href="m13-4.html">Unit & Feature Tests (Pest)</a></li>
                <li><a href="m13-5.html">Database Testing & Seeding</a></li>
                <li><a href="m13-6.html" class="active">Mocking & Spies</a></li>
                <li><a href="m13-7.html">Browser Testing (Dusk)</a></li>
                <li><a href="m13-8.html">Static Analysis & Debugging</a></li>
            </ul>
        </nav>
    </div>

    <main>
        <h2>Het probleem met externe services</h2>
        <p>In moderne applicaties ben je vaak afhankelijk van externe partijen: een mailprovider (Mailgun/Postmark), een weer-API, een betaalprovider (Mollie/Stripe) of een SMS-gateway. Als je een test schrijft die deze code uitvoert, loop je tegen grote problemen aan:</p>
        <ul>
            <li><strong>Snelheid:</strong> Echte API calls over het internet zijn traag (honderden milliseconden). Tests moeten in milliseconden draaien.</li>
            <li><strong>Kosten:</strong> SMS-diensten kosten geld per bericht. API's hebben vaak rate-limits.</li>
            <li><strong>Neveneffecten:</strong> Je wilt niet per ongeluk test-emails naar echte klanten sturen of echte betalingen uitvoeren.</li>
        </ul>
        <p>De oplossing is <strong>Mocking</strong> (doen alsof). We vervangen de echte service tijdelijk door een "nep" variant die precies doet wat wij zeggen.</p>

        <h3>HTTP Mocking (De `Http::fake` methode)</h3>
        <p>In Module 12 hebben we de <code>Http</code> client gebruikt om externe API's aan te roepen. Laravel maakt het kinderlijk eenvoudig om deze te faken. Je hoeft je originele code niet aan te passen; Laravel onderschept het verzoek automatisch.</p>

        <p>Stel je hebt een `WeatherService` die het weer ophaalt. In je test wil je niet echt naar `api.weather.com` verbinden.</p>

        <div class="note-box">Bestand: <code>tests/Feature/WeatherTest.php</code></div>
        <pre><code class="language-php">
use Illuminate\Support\Facades\Http;
use App\Services\WeatherService;

test('it gets weather from api correctly', function () {
    // 1. Arrange: We vertellen Laravel: "Als er een request komt naar
    // api.weather.com, geef dan ALTIJD dit nep-antwoord terug."
    Http::fake([
        'api.weather.com/*' => Http::response(['temp' => 25], 200),
    ]);

    // 2. Act: We roepen onze eigen code aan (die intern de Http facade gebruikt)
    // De WeatherService 'denkt' dat hij met het internet praat,
    // maar krijgt direct ons nep-antwoord.
    $service = new WeatherService();
    $result = $service->getForecast('Rotterdam');

    // 3. Assert: We checken of onze service de data goed verwerkt
    expect($result['temp'])->toBe(25);
});
        </code></pre>

        <h3>Controleren of een call is gemaakt (Spying)</h3>
        <p>Soms wil je niet alleen de data faken, maar ook zeker weten <em>dat</em> de call is gemaakt. Bijvoorbeeld: heeft mijn code wel de juiste API-key meegestuurd?</p>

        <pre><code class="language-php">
    // We kunnen achteraf checken of de call daadwerkelijk gedaan is
    // en of de parameters klopten.
    Http::assertSent(function ($request) {
        return $request->url() == 'https://api.weather.com/v1/forecast' &&
               $request['city'] == 'Rotterdam';
    });
        </code></pre>

        <h3>Mail Mocking</h3>
        <p>Hetzelfde principe geldt voor e-mail. Met <code>Mail::fake()</code> wordt er niets verstuurd, maar Laravel houdt in het geheugen bij <em>wat</em> er verstuurd zou zijn. Dit is essentieel voor het testen van registraties of bestellingen.</p>

        <pre><code class="language-php">
use Illuminate\Support\Facades\Mail;
use App\Mail\OrderShipped;

test('order confirmation is sent', function () {
    // 1. Arrange: Blokkeer alle uitgaande mail
    Mail::fake();

    // 2. Act: Doe iets waardoor een mail verstuurd zou moeten worden
    // (bijvoorbeeld een bestelling plaatsen via een POST request)
    $this->post('/orders', ['product_id' => 1]);

    // 3. Assert: Check of de mail "verzonden" is in het geheugen
    // We checken of de Mailable class is gebruikt én of de ontvanger klopt.
    Mail::assertSent(OrderShipped::class, function ($mail) {
        return $mail->hasTo('klant@voorbeeld.nl');
    });

    // Of check dat er juist GEEN mail is verstuurd (bijv. bij een fout)
    // Mail::assertNothingSent();
});
        </code></pre>
    </main>
</div>
<footer><div class="footer-content"><p>&copy; 2025 Techniek College Rotterdam</p></div></footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script>hljs.highlightAll();</script>
</body>
</html>