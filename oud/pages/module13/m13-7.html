<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <title>Browser Testing met Dusk - Quality Assurance - Laravel 12</title>
    <link rel="stylesheet" href="../../../style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="../../../script.js" defer></script>
</head>
<body>
<div class="top-bar"><div class="top-bar-content"><div class="nav-group"><a href="../module12/m12-7.html">« Services & Features</a></div><div class="nav-group theme-switcher"><select id="theme-switcher"><option value="blue">Blauw</option></select></div></div></div>

<div class="container">
    <div class="header-nav-block">
        <header>
            <h1>Quality Assurance</h1>
            <p>Codekwaliteit, testen met PHPUnit, Pest & Dusk, en debugging.</p>
        </header>
        <nav>
            <ul>
                <li><a href="m13-1.html">Introductie & PHPUnit</a></li>
                <li><a href="m13-2.html">Unit vs Feature Tests</a></li>
                <li><a href="m13-3.html">Introductie Pest</a></li>
                <li><a href="m13-4.html">Unit & Feature Tests (Pest)</a></li>
                <li><a href="m13-5.html">Database Testing & Seeding</a></li>
                <li><a href="m13-6.html">Mocking & Spies</a></li>
                <li><a href="m13-7.html" class="active">Browser Testing (Dusk)</a></li>
                <li><a href="m13-8.html">Static Analysis & Debugging</a></li>
            </ul>
        </nav>
    </div>

    <main>
        <h2>Laravel Dusk: End-to-End Testing</h2>
        <p>Tot nu toe hebben we Unit en Feature tests gezien. Deze testen de PHP-kant van je applicatie. Ze zijn perfect om te controleren of je API de juiste JSON teruggeeft, of dat je controller de juiste view laadt. Maar ze hebben één grote beperking: ze "zien" niet wat de gebruiker ziet en ze voeren geen JavaScript uit.</p>
        <p>Als je een moderne applicatie bouwt met <strong>Livewire, Vue, React of AlpineJS</strong>, gebeurt er veel in de browser. Denk aan een modal die opent, een dropdown die uitklapt, of een formulier dat dynamisch velden toevoegt. Om dit te testen heb je <strong>End-to-End (E2E)</strong> testing nodig. Hiervoor gebruiken we <strong>Laravel Dusk</strong>.</p>

        <h3>Wat is Dusk?</h3>
        <p>Laravel Dusk is een tool die een echte Google Chrome browser bestuurt. Het is als een robotgebruiker: het opent de browser, typt in velden, klikt op knoppen en controleert wat er op het scherm staat. Het ziet precies wat de echte gebruiker ziet.</p>

        <h3>Installatie</h3>
        <p>Omdat Dusk een echte browser nodig heeft en relatief zwaar is, installeren we het alleen als development dependency. Het wordt (meestal) niet op de productie-server gebruikt.</p>

        <div class="note-box">Terminal</div>
        <pre><code class="language-bash">
# Installeer de package
composer require --dev laravel/dusk

# Installeer de Chrome driver
php artisan dusk:install
        </code></pre>

        <h3>Een Dusk Test Schrijven</h3>
        <p>Dusk tests worden opgeslagen in de map <code>tests/Browser</code>. De syntax is ontworpen om heel leesbaar te zijn en lijkt op natuurlijke taal ("Visit login, type email, press login").</p>
        <p>Laten we een test schrijven die controleert of een gebruiker kan inloggen. We maken eerst een gebruiker aan (Dusk heeft toegang tot je database!) en laten de browser vervolgens de inlogflow doorlopen.</p>

        <div class="note-box">Bestand: <code>tests/Browser/LoginTest.php</code></div>
        <pre><code class="language-php">
namespace Tests\Browser;

use App\Models\User;
use Laravel\Dusk\Browser;
use Tests\DuskTestCase;

class LoginTest extends DuskTestCase
{
    public function test_user_can_login()
    {
        // 1. Maak een user aan in de database
        $user = User::factory()->create([
            'email' => 'test@example.com',
            'password' => bcrypt('password'), // Zorg dat we het wachtwoord weten!
        ]);

        // 2. Start de browser sessie
        $this->browse(function (Browser $browser) use ($user) {
            $browser->visit('/login')               // Ga naar de login pagina
                    ->type('email', $user->email)   // Vul het email veld in
                    ->type('password', 'password')  // Vul het wachtwoord in
                    ->press('Inloggen')             // Klik op de knop met tekst 'Inloggen'
                    ->assertPathIs('/dashboard')    // Check of we nu op /dashboard zijn
                    ->assertSee('Welkom terug!');   // Check of we de welkomsttekst zien
        });
    }
}
        </code></pre>

        <h3>Interactie met JavaScript</h3>
        <p>De ware kracht van Dusk komt naar boven bij JavaScript interacties. Stel je hebt een knop die een modal opent. Een normale Feature test kan dit niet testen, maar Dusk wel.</p>

        <pre><code class="language-php">
$browser->visit('/profile')
        ->press('Verwijder Account')        // Klik op de knop
        ->waitForText('Weet je het zeker?') // Wacht tot de JS modal is verschenen
        ->press('Ja, verwijder')            // Klik in de modal
        ->assertPathIs('/');                // Check redirect
        </code></pre>

        <h3>Tests Uitvoeren</h3>
        <p>Dusk tests draai je niet met het standaard <code>php artisan test</code> commando, maar met een eigen commando. Als je dit uitvoert, zie je (tenzij je headless mode gebruikt) de browser daadwerkelijk openen en als een bezetene door je applicatie klikken.</p>

        <div class="note-box">Terminal</div>
        <pre><code class="language-bash">php artisan dusk</code></pre>

        <h3>Belangrijke Aandachtspunten</h3>
        <ul>
            <li><strong>Snelheid:</strong> Dusk tests zijn traag. Een Unit test duurt milliseconden, een Dusk test seconden. Gebruik ze spaarzaam.</li>
            <li><strong>Critical Path:</strong> Gebruik Dusk vooral voor je "Happy Path" en kritieke flows die JavaScript vereisen (zoals afrekenen of complexe wizards).</li>
            <li><strong>Database:</strong> Dusk draait in een ander proces dan je test-runner. Zorg dat je <code>.env.dusk.local</code> goed is ingesteld, vaak met een aparte test-database, om te voorkomen dat je je development data overschrijft.</li>
        </ul>
    </main>
</div>
<footer><div class="footer-content"><p>&copy; 2025 Techniek College Rotterdam</p></div></footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script>hljs.highlightAll();</script>
</body>
</html>